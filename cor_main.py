import numpy as np
# can do something fancier here to automate string generation 
import matplotlib.pyplot as plt


# Import all the data 
from transdict_err import *
from NXdata        import * 


# Now we have a dictionary that has all the transition locations and a collection of classes that have all the BLinfo generated by XFOIL. 


# Function that takes a string and a dictionary, then outputs a list of all the keys in the dictionary that contain that string
def get_key_list( substring,inpdict ):
	outkeys = [];
	for key in inpdict.keys():
		if substring in key: outkeys.append( key )
	return outkeys


# take a string and a substring a return the difference 
def get_str_diff( string,substring ):
	return list(string)[len(list(substring)):] 
	

# take in array and scalar, then return the index of the array 
# that is nearest in value to scalar 
def near_ind( array,value ):
	return (np.abs(array-value)).argmin()


############################################################
# Inputs:
#	k_s  -- Some "equivalent" sand grain roughness height
#	K    -- Relaminarization parameter (nu/U_e)*(dU_e/ds)
#       mutnu - Frictional velocity divided by nu (k^+ = mutnu*k_s) 
#	dstar - Boundary layer diplacement thickness 
# Output:
#       quant - Some combination of input parameters f(k^+)*g(K) 
#
def comp_quant( k_s,K,mutnu,dstar ):
	""" Money Function """
	quant = [] 
	C     = 1.0e3
	C2    =  0.0 
	for i in range(len(K)):
		kplus = mutnu[i]*k_s 
		# do not add if we are outside thresholds 
		if kplus < 5.0:
			quant.append( float(0.0) )
		else:
			quant.append( float( (np.exp(C*K[i]))*kplus**4) )  
	return quant 

############################################################



# example key syntax               - '3_2_140_15_2_0'
# example name of class from xfoil - 'R1600000_0_A5X'

 # OK let's just do something !!! Find N_crit based on 
rtcrt,ncrit,alphs,dist = [],[],[],[] 
Reystr = [ '1_6','2_4','3_2' ]
rhts   = [ '100','140' ] 
for rstr in Reystr:
    rnum    = ''.join([list(rstr)[0],list(rstr)[2]]) 
    for rht in rhts:
	k_s = float(rht)*1.0e-6
        pq =[] 
        # automate by generating the substring on the fly 
        # subst   = '2_4_140_03_'
        subst   = ''.join([rstr,'_',rht,'_15_' ])
        curkeys = get_key_list( subst,transdict )
        for key in curkeys:
        	err     = False
        	aoastr  = ''.join( get_str_diff( key,subst ))
        	classtr = ''.join( ['R',rnum,'00000_0_A',aoastr,'X' ] )
        	try: thisclass = globals()[ classtr ]
        	except: err = True
        	if not err:
        	 	# extract the data from class for this configuration 
        		xu   = np.array( getattr( thisclass, 'xu'    ) )
        		su   = np.array( getattr( thisclass, 'su'    ) )
        		n    = np.array( getattr( thisclass, 'nu'    ) )
        		rt   = np.array( getattr( thisclass, 'rtu'   ) )
        		Dcp  = np.array( getattr( thisclass, 'Dcpu'  ) )  
        		cf   = np.array( getattr( thisclass, 'cfu'   ) )    
        		K    = np.array( getattr( thisclass, 'Ku'    ) )    
        		mut  = np.array( getattr( thisclass, 'mutnu' ) )    
        		dstr = np.array( getattr( thisclass, 'dstu'  ) )    
        		# compute the correlation function 
	               	quant = comp_quant( k_s,K,mut,dstr )  
        		foo   = getattr( thisclass, 'intquant' ) 
        		trans = float( transdict[key][0] ) 
        		ind   = near_ind( xu,trans )
        		ncrit.append( 1.0 - (n[-1]  -  n[ind])/n[-1] )
        		rtcrt.append( (rt[-1] - rt[ind])/rt[-1] ) 
        		alphs.append( aoastr )
        		dist.append( foo(0.12,0.02,np.array(quant)) )		  
    		pq.append( foo(0.12,0.02,np.array(quant)) )
    		plt.plot( dist,ncrit,'*' ) 

for i in range(len(ncrit)): 
	print ncrit[i],rtcrt[i], alphs[i],dist[i] 

plt.show() 
print np.corrcoef( ncrit, dist ) 



















